[Главная](../main.md)

# Архитектура

Архитектура проектов основана на адаптированном Clean Architecture.
UI-cлой основан на вариации MVVM + немного MVI.

Выделены следующие слои:

1. **Domain** — сущности предметной области
1. **Repository** — репозитории, совершают запросы к источникам данных и переобразуют ответы в сущности из слоя domain
1. **Interactor** — интеракторы, содержат бизнес-логику, не зависят от фреймворка и архитектуры
1. **WidgetModel** — логика экрана или отдельного виджета, связующее звено между виджетом и интерактором
1. **Widget** — вёрстка экрана или отдельного виджета

*Пункты 4-5 принадлежат слою V-VM в MVVM.*

**Widget** - слой отображения, содержит только декларативную логику. Взаимодействует с WidgetModel посредством *Action* и *StreamedState* (по факту аналог binding в mvvm).

**WidgetModel** - связывает слой виджетов с бизнесс логикой посредством модели. Может содержать логику необходимую для слоя отображения.

**Model** - слой связи WidgetModel с чистой бизнесс-логикой. Является набором контрактов (performer), которые модель может выполнить. Каждый контракт это изолированная атомартая часть бизнесс-логики. WidgetModel инициирует действие с помощью сообщения об изменении (change). Модель ищет соответствующий данному изменению контракт и выполняет его.

**BusinessLogic** - слой бизнесс логики, содержит  чистую логику на dart, совсем не зависит от Flutter.

![](../images/mwwm.png) 

Cлой бизнесс логики обычно содержит сущности следующих типов, каждая из которых имеет свою зону ответственности.

**Интерактор**

Интерактор - сущность, которая реализует логику некоторого бизнес процесса. Интерактор не зависит от платформы, в нем реализуется только логика use case.

**Репозиторий**

Говоря о репозиториях, следует вспомнить паттерн, который собственно так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой абстракции над какими-либо конкретными источниками данных, будь то например база данных или веб-сервис. Задача репозитория стать промежуточным звеном между тем кто запрашивает данные и тем кто их отдает. Важно понимать, что все что находится выше репозитория не должно знать о том, как он устроен и откуда он берет эти данные. Это может быть сетевой запрос, запрос в базу данных или же все вместе, так называемый гибридный запрос, который подразумевает проведение конкатенации запросов на сервер и кеш по некому установленному вами правилу.

**Storage**

Обертка над источником данных. Следуя принципам SOLID, каждый класс должен иметь единственную ответственность. Нельзя смешивать логику нескольких классов в один. Сущность Storage предназначена для абстрагирования работы с хранилищем данных. Например есть кейс, когда необходимо сохранять данные пользователя на локальное устройство. Это необходимо делать в различных форматах. Например xml и json. Правильным решением в этом случае будет реализовать отдельно низкоуровневое api для работы с файловой системой устройства - FileSystem. Поверх него реализовать две "обертки" JsonStorage и XmlStorage, которые будут использовать FileSystem для доступа к файловой системе, а логика сохранения данных будет реализоавана непосредственно в этих классах.

**Mapper**

Объект, который переводит один тип данных в другой.
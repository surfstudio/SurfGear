[Главная](../main.md)

# Интерактор

Интерактор — сущность, реализующая
логику некоторого бизнес процесса. Интерактор не зависит от платформы, в нем реализуется только логика use case, не затрагивая ui логику.
Интерактор не привязывается к какому-либо экрану. Один и тот же интерактор можно использовать в 
нескольких экранах.

Типичный пример использования:

В приложении есть экран авторизации и экран заказов.  
Необходимо проверять, залогинен ли пользователь на текущий момент.
Если да, то при открытии приложения переводить на экран заказов и показывать контент, который доступен только авторизованному пользователю.
Если нет, то оставаться на экране авторизации, но дать возможность просматривать заказы, которые доступны неавторизованному пользователю.

Для решения этой задачи следует создать интерактор, который реализует логику проверки
авторизации пользователя — AuthInteractor. В этом интеракторе происходит получение локального токена через TokenRepository.
Далее интерактор совершает запрос на сервер через AuthRepository с проверкой на валидность текущего токена и возвращает результат.
Таким образом интерактор обьединяет в себе работу нескольких репозиториев и выполняет тот use case, который нужен в каком-то конкретном месте.

Чтобы проверить, находится ли пользователь в системе на текущий момент,
AuthInteractor можно использовать как на экране авторизации, так и на экране отображения заказов. 

Интеракторы взаимодействуют с презентационным слоем только через сущность WidgetModel.

Публичные методы API интерактора строится преимущественно на Rx.

## Типовые сущности, принадлежащие слою Interactor

Рассмотрим наиболее распространенные сущности, принадлежащие к этому слою.

### 1. Репозиторий

Говоря о репозиториях, следует вспомнить одноимённый шаблон проектирования “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, например, база данных или веб-сервис. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что пользователи репозитория не должны знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кэш по
некому установленному вами правилу.

### 2. Storage

Хранилище — это обертка над источником данных c единственной ответственностью. Например, необходимо сохранять данные пользователя на локальное устройство в двух разных форматах: xml и json. Правильным решением будет
реализовать низкоуровневое api для работы с файловой системой FileSystem и два хранилища JsonStorage и XmlStorage, которые будут использовать FileSystem для доступа к файловой системе, а логика сохранения
данных будет реализована непосредственно в этих классах. 

### 3. Mapper

Класс, который преобразует данные из одного типа в другой.

### 4. Интерактор инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в отдельный интерактор.

Интерфейс данного интерактора будет описан всего лишь одним методом - `initialize()`.

### 5. Интерактор смены сессии пользователя

Этот интерактор отвечает за действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть очистка
кэша, запрос на logout, кэширование токена и тд.

## Рассылка событий через Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на экране А должно вызывать обновление данных на экране Б. 
Причем данное действие не является результатом экрана А. Тогда можно пробросить событие через общий интерактор у данных экранов.
Данный кейс показывает, что приоритетнее использовать именно интерактор для обновления данных, а не результат выполнения экрана.
Маршрут с параметрами следует использовать там, где очевиден возврат результата, например, некая форма, которая возвращает заполненные данные на предыдущий экран.
Реализовать проброс этого события можно через создания Subject'а внутри интерактора.

Пример: 
```dart
/// Интерактор сессии пользователя
class SessionChangedInteractor {
  final AuthInfoStorage _ts;

  final PublishSubject<SessionState> sessionSubject = PublishSubject();

  SessionChangedInteractor(this._ts);

  void onSessionChanged() {
    sessionSubject.add(SessionState.LOGGED_IN);
  }

  void forceLogout() {
    sessionSubject.add(SessionState.LOGGED_OUT);
    silentLogout();
  }

  void silentLogout() {
    _ts.clearData();
  }
}

enum SessionState { LOGGED_IN, LOGGED_OUT }
```
Далее необходимо подключить SessionChangedInteractor в WidgetModel и подписаться на изменения 
в sessionSubject:
```dart

class FirstWidgetModel {
   final SessionChangedInteractor _changeInteractor;
   
   Action sessionChangedAction = Action();
   
   FirstWidgetModel(WidgetModelDependencies baseDependencies,
        this._changeInteractor,) : super(baseDependencies); 
   
    @override
     void onLoad() {
      bind(sessionChangedAction, (_) => _changeInteractor.onSessionChanged());
       super.onLoad();
     }
}

class SecondWidgetModel {
   final SessionChangedInteractor _changeInteractor;
   
   SecondWidgetModel(WidgetModelDependencies baseDependencies,
        this._changeInteractor,) : super(baseDependencies);
   
    @override
     void onLoad() {
       subscribeHandleError(_changeInteractor.sessionSubject, (sessionState){
         print(sessionState.toString());});
       super.onLoad();
     }
}
```
[Главная](../main.md)

# Уменьшение размера сборки приложения

## Android

Файлы занимающие значительный обьем в сборке:
- `libflutter.so` - run-time библиотека фреймворка. Комманда flutter обещает оптимизировать размер этого файла в будущих версиях, либо вынести его в отдельно устанавливаемый run-time пакет; 
- `libapp.so` - скомпилированное приложение;
- `classes.dex` - собранные в кучу нативные части всех используемых библиотек. Большинство библиотек уже проходило через обфускатор;
- каталог `res` - тут собраные системные ресурсы, такие как иконки Material и Cupertino, так же коллекция assets из каталога проекта;
- все остальное в сумме менее 1% по объему;

Пара файлов `libflutter.so` и `libapp.so` помещаются в сборку для каждой поддерживаемой платформы, то есть если собрать однусборку для x86, x86_64, armeabiv7a, arm64_v8a, то сборка занимает значительные объем.
Как вариант, можно запускать сборку с параметром `--split-per-abi`:
```
flutter build apk --split-per-abi
```
В таком случае мы получаем несколько сборок для разных платформ, каждая из которых будет менее 10 мб для release.

### App Bundles

Aab-файл это формат загрузки, который включает в себя весь скомпилированный код и ресурсы приложения в одном артефакте сборки.

Если использовать сборку App Bundles командой:
```
flutter build appbundle
```
То в результате получается `*.aab` файл, который по объему соответствует "толстому" apk-файлу.

Если требуется дистрибуция приложения через Google Play, тогда выгоднее использовать aab-файл.
Потому что, в этому случае, после загрузки подписанного пакета приложения в Google Play есть все, что нужно, 
для создания и подписи apk-файлов приложения и предоставления их пользователям посредством динамической доставки. 
Тоесть пользователь скачает с Google Play файл apk, который будет содержать бинарные файлы только одной, требуемой платформы.

Если дистрибуция приложения осуществляется с помощью других сервисов, или просто передачей файлов, то передавать aab-файл нет смысла, 
потому что его нельзя установить на устройство.
Нужно с помощью утилит приготовить из него либо "толстый" apk файл под все платформы, либо отдельные apk файлы для разных платформ.
В таком случае проще воспользоваться сборкой apk с параметром `--split-per-abi`.

Этапы борьбы команды flutter за размер релизной сборки приложения можно наблюдать в [этом тикете](https://github.com/flutter/flutter/issues/16833)
Команда flutter переодически уменьшает размер `libflutter.so` за счет оптимизации используемых бибилиотек и за счет использования последних версий 
компилятора, который генерит более компактный код.


## iOS

Сборка приложения для iOS имеет размер больше, чем сборка этого же приложения для Android.
Главным образом потому, что Apple шифрует двоичные файлы в пределах IPA, делая сжатие менее эффективным.

Общая рекомендация - предпочесть загрузку объемных данных из assets вместо объявления статических констант в коде.

Apple позаботилось о частичной загрузке обновлений приложения из App Store.
Цитата из базы знаний: 
```
Для устройств под управлением iOS 7.1 и более поздних версий пакет обновления может содержать только различия 
между старой и новой версиями измененного файла, а не полного файла. Это может значительно уменьшить размер пакета 
обновления в случае, если изменяется только небольшая часть большого файла, но увеличит время установки обновления 
на устройстве. 
```


## Ресурсы

Какой формат данных предпочесть для хранения графических файлов?

- `PNG` - формат представления растровых изображений, имеет собственное, достаточное эффективное сжатие
- `JPG` - формат представления растровых изображений, имеет собственное, достаточное эффективное сжатие. 
    Предпочтительнее использовать `PNG` формат, поскольку у `JPG` формата сжатие с потерями и на изображении могут быть заметны артефакты.
- `SVG` - формат представления векторных изображений, в основе имеет текстовый формат, сжимается внутри артефакта сборки
- `TTF` - формат файла шрифтов, который можно создать из набора svg-файлов, бинарный формат, сжимается внутри артефакта сборки.
    Для получения файла шрифтов из набора svg файлов можно использовать [утилиту](https://github.com/ilikerobots/polyicon)
- `FLR` - формат Flare анимаций, текстовый формат, сжимается внутри артефакта сборки

Ни один из перечисленных форматов не дает значительного преемущества в объеме информации, сохраняемой внутри артефакта сборки.

Общая рекомендация - предпочесть загрузку объемных данных из assets вместо объявления статических констант в коде.


## Обфускация Dart кода

На примере реального приложения (ROS) объем "жирного" apk:

- без обфускации - 16 131 443 B
- с обфускацией - 16 031 895 B

Однако режим обфускации дает еще некоторые побочные эффекты.
Например печать строкового представления типа объектов, трассировки стека и прочее,
будут вести себя немного иначе, чем ожидается от программы Dart, работающей в обычном режиме - потому что идентификаторы будут искажены.

Все идентификаторы, которые возвращают методы, такие как 
Object.runtimeType, 
Type.toString, 
Enum.toString, 
Stacktrace.toString, 
Symbol.toString, 
будут возвращать искаженные результаты. Любой код или тесты, которые полагаются на результат этих функций - перестанут работать.

Однако, например для расшифровки трассировки стека, можно добавить параметр
`--save-obfuscation-map=<filename>` который заставляет VM хранить отображение между оригинальными именами и искаженными в заданных `filename`.
Отображение кодируется как массив JSON `[original_name_0, obfuscated_name_0, original_name_1, obfuscated_name_1, ...]`.
